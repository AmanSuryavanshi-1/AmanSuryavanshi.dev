// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROCESS AI STRATEGY & MERGE CONTEXT (V4 - FINAL, ROBUST JSON PARSING)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

console.log('ğŸ“‹ V4: Starting robust JSON parsing...');
// STEP 1: GET INPUTS FROM TWO DIFFERENT SOURCES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const geminiRawOutput = $input.first().json;
const originalContext = $('Code â€“ CONTEXT MERGER').first().json;

if (!geminiRawOutput) {
  throw new Error('âŒ No input from parent node (Gemini - AI CONTENT STRATEGIST).');
}
if (!originalContext) {
  throw new Error(`âŒ Could not find data from referenced node: "$('Code â€“ CONTEXT MERGER')". Please verify the name.`);
}
console.log('âœ… Successfully loaded data from parent and context nodes.');

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// STEP 2: ROBUSTLY EXTRACT, SANITIZE, AND REPAIR JSON
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let strategy;
try {
  let rawText = geminiRawOutput.content?.parts[
        0
    ]?.text || '';

  // Handle OpenRouter / Alternative LLM Providers
  if (!rawText && geminiRawOutput.response) {
    console.log('ğŸ¤– Detected OpenRouter/Alternative LLM output format');
    rawText = geminiRawOutput.response;
    }

  if (!rawText) {
    throw new Error('Text content from AI is empty.');
    }
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 1: EXTRACT JSON SUBSTRING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const firstBrace = rawText.indexOf('{');
  const lastBrace = rawText.lastIndexOf('
    }');

  if (firstBrace === -1) {
    throw new Error('Could not find opening "{" in AI response.');
    }
    // If no closing brace found, take everything after the first brace
  let jsonString = lastBrace > firstBrace 
    ? rawText.substring(firstBrace, lastBrace + 1)
    : rawText.substring(firstBrace);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 2: AGGRESSIVE QUOTE SANITIZATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  console.log('ğŸ§¹ Phase 2: Sanitizing all quote variations...');
  
  // Replace ALL fancy/international double quotes with standard "
  jsonString = jsonString.replace(/[\u201C\u201D\u201E\u201F\u00AB\u00BB\u2033\u301D\u301E
    ]/g, '"');
    // Replace ALL fancy single quotes with standard '
  jsonString = jsonString.replace(/[\u2018\u2019\u201A\u201B\u2032
    ]/g,
    "'");
  
  // Fix trailing commas
  jsonString = jsonString
    .replace(/,(\s*[
}\
]
])/g, '$1') // Remove trailing commas before } or ]
    .replace(/,\s*,/g, ','); // Fix double commas

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PHASE 3: ATTEMPT TO REPAIR TRUNCATED JSON
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  console.log('ğŸ”§ Phase 3: Attempting JSON repair...');
  
  // Count unclosed brackets
  let openBraces = 0;
  let openBrackets = 0;
  let inString = false;
  let prevChar = '';
  
  for (let i = 0; i < jsonString.length; i++) {
    const char = jsonString[i
];
    if (char === '"' && prevChar !== '\\') {
      inString = !inString;
}
    if (!inString) {
      if (char === '{') openBraces++;
      if (char === '
}') openBraces--;
      if (char === '[') openBrackets++;
      if (char === '
]') openBrackets--;
}
    prevChar = char;
}
// Close any unclosed structures
  if (openBraces > 0 || openBrackets > 0) {
    console.log(`âš ï¸ Detected truncated JSON: ${openBraces
} unclosed braces, ${openBrackets
} unclosed brackets. Attempting repair...`);
    
    // If we're likely in the middle of a string value, close it
    if (inString) {
      jsonString += '"';
}
// Add closing brackets/braces
    jsonString += '
]'.repeat(Math.max(0, openBrackets));
    jsonString += '
}'.repeat(Math.max(0, openBraces));
    
    console.log('âœ… JSON structure repaired.');
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PHASE 4: PARSE WITH FALLBACK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  try {
    strategy = JSON.parse(jsonString);
    console.log('âœ… Strategy parsed successfully!');
} catch (parseError) {
    console.error('âŒ JSON.parse failed after repair:', parseError.message);
    console.log('ğŸ“ Attempting lenient extraction of key fields...');
    
    // Last resort: Extract what we can using regex
    const extractField = (fieldName) => {
// Match any quote style followed by field name, then capture the value
      const regex = new RegExp(`[
""\u201C\u201D\u201E\u00AB\u00BB
]${fieldName
}[
""\u201C\u201D\u201E\u00AB\u00BB
]\\s*:\\s*[
""\u201C\u201D\u201E\u00AB\u00BB
]([^""\u201C\u201D\u201E\u00AB\u00BB
]*)`, 'i');
      const match = jsonString.match(regex);
      return match ? match[
1
] : null;
};
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CRITICAL FIX: Extract needs_images with proper Unicode handling
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Look for needs_images followed by true or false (handles all quote styles)
    const needsImagesRegex = /[
""\u201C\u201D\u201E\u00AB\u00BB
]?needs_images[
""\u201C\u201D\u201E\u00AB\u00BB
]?\s*:\s*(true|false)/i;
    const needsImagesMatch = jsonString.match(needsImagesRegex);
    
    // Also try without quotes (some LLMs output unquoted keys)
    const needsImagesAltRegex = /needs_images\s*:\s*(true|false)/i;
    const needsImagesAltMatch = jsonString.match(needsImagesAltRegex);
    
    const needsImages = needsImagesMatch 
      ? needsImagesMatch[
1
].toLowerCase() === 'true' 
      : (needsImagesAltMatch ? needsImagesAltMatch[
1
].toLowerCase() === 'true' : false);
    
    console.log(`ğŸ” needs_images extraction: match1=${needsImagesMatch?.[
1
]
}, match2=${needsImagesAltMatch?.[
1
]
}, result=${needsImages
}`);
    
    // Extract rationale if present (handles all quote styles)
    const rationaleRegex = /[
""\u201C\u201D\u201E\u00AB\u00BB
]?rationale[
""\u201C\u201D\u201E\u00AB\u00BB
]?\s*:\s*[
""\u201C\u201D\u201E\u00AB\u00BB
]([^""\u201C\u201D\u201E\u00AB\u00BB
]{
0,
500
})/i;
    const rationaleMatch = jsonString.match(rationaleRegex);
    const rationale = rationaleMatch ? rationaleMatch[
1
] : 'Could not extract rationale';

    strategy = {
      strategy_summary: extractField('strategy_summary') || 'Strategy extraction failed - manual review needed',
      source_analysis: extractField('source_analysis') || 'Could not extract source analysis',
      core_insight: extractField('core_insight') || 'Could not extract core insight',
      platform_strategies: {
        twitter: { hashtags: [], content_breakdown: [], must_include: []
},
        linkedin: { hashtags: [], structure: 'Case Study', must_include: []
},
        blog: { seo_keywords: [], structure: [], must_include: []
}
},
      image_strategy: { 
        needs_images: needsImages, // â† NOW CORRECTLY EXTRACTED
        rationale: rationale,
        specific_prompts: []
},
      _parsing_error: true,
      _original_error: parseError.message
};
    
    console.log(`âš ï¸ Using fallback strategy. needs_images extracted as: ${needsImages
}`);
}
} catch (error) {
  console.error('âŒ Strategy extraction failed:', error.message);
  throw new Error(`Failed to parse Gemini strategy: ${error.message
}`);
}
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// STEP 3: VALIDATE AND CREATE MASTER DATA OBJECT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const requiredFields = ['strategy_summary', 'source_analysis', 'platform_strategies'
];
const missingFields = requiredFields.filter(field => !strategy[field
]);

if (missingFields.length > 0) {
  throw new Error(`Strategy object is missing required fields: ${missingFields.join(', ')
}`);
}
console.log('âœ… Strategy structure validated.');

const masterData = {
  personalContext: originalContext.personalContext,
  sourceContent: originalContext.sourceContent,
  research: originalContext.research,
  workflowMetadata: originalContext.workflowMetadata,
  strategy: strategy
};

console.log('âœ… Master data object created successfully.');
console.log('ğŸ“¦ Final output contains keys:', Object.keys(masterData));

return [
{ json: masterData
}
];
