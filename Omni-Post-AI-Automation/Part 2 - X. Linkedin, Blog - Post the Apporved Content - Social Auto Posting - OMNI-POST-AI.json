{
  "nodes": [
    {
      "parameters": {
        "resource": "databasePage",
        "operation": "getAll",
        "databaseId": {
          "__rl": true,
          "value": "21a34bf1-f7e5-8035-b16f-d5ebf63a86a9",
          "mode": "list",
          "cachedResultName": "Social Content Queue",
          "cachedResultUrl": "https://www.notion.so/21a34bf1f7e58035b16fd5ebf63a86a9"
        },
        "returnAll": true,
        "filterType": "manual",
        "filters": {
          "conditions": [
            {
              "key": "Status|select",
              "condition": "equals",
              "selectValue": "Approved"
            }
          ]
        },
        "options": {}
      },
      "id": "0391cbc9-e13d-4f70-b6f1-45232c6d4587",
      "name": "Notion – Get Approved",
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2,
      "position": [
        -5376,
        -592
      ],
      "credentials": {
        "notionApi": {
          "id": "je8hKPK6RzYSk4JA",
          "name": "Notion account 2"
        }
      }
    },
    {
      "parameters": {},
      "id": "b99b12ff-ea97-4b54-bc27-adf2fa13f700",
      "name": "Start Posting",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -5600,
        -592
      ]
    },
    {
      "parameters": {
        "jsCode": "// Takes a single Notion item and finds all associated files in Google Drive.\n\nconst item = $input.first().json;\n\n// --- 1. Extract Core Information ---\n// Property names\nconst driveFolderUrl = item.property_drive_folder_link;\nconst sessionId = item.property_session_id;\nconst twitterDraftUrl = item.property_twitter_draft_url;\nconst linkedinDraftUrl = item.property_linked_in_draft_url;\nconst blogDraftUrl = item.property_blog_draft_url;\n\nif (!driveFolderUrl) {\n  throw new Error('FATAL: Drive Folder Link is missing from Notion item.');\n}\n\n// --- 2. Extract Folder ID from URL ---\nconst folderIdMatch = driveFolderUrl.match(/folders\\/([a-zA-Z0-9_-]+)/);\nconst folderId = folderIdMatch ? folderIdMatch[1] : null;\n\nif (!folderId) {\n  throw new Error(`FATAL: Could not extract Folder ID from URL: ${driveFolderUrl}`);\n}\n\n// --- 3. Pass Folder ID to the next node ---\n// The next node will list all files in this folder.\nreturn {\n  json: {\n    notionItem: $input.first().json, // Keep the original Notion data\n    sessionId: sessionId,\n    folderId: folderId,\n     draftUrls: {\n      twitter: twitterDraftUrl,\n      linkedin: linkedinDraftUrl,\n      blog: blogDraftUrl\n    }\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -5152,
        -592
      ],
      "id": "09f03e1e-62f3-4873-a6bf-ce48a219c406",
      "name": "Extract Folder Details"
    },
    {
      "parameters": {
        "resource": "fileFolder",
        "searchMethod": "query",
        "queryString": "=parents = '{{$json.folderId}}' and trashed = false",
        "returnAll": true,
        "filter": {},
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        -4928,
        -592
      ],
      "id": "000a486f-65b1-4126-a7eb-6f420b95dee2",
      "name": "List Drive Folder Files",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "1hcyFpBqSOMDRDna",
          "name": "Google Drive Adude"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// FINAL, 100% ROBUST ASSET ORGANIZER (Nov 2025 revision)\ntry {\n  // Input from \"List Drive Files\"\n  const files = $input.all();\n  // Input from \"Extract Folder Details\"\n  const { notionItem, sessionId } = $('Extract Folder Details').first().json;\n\n  // --- Helpers ---\n  // Safely gets a property from either .json or top-level\n  function getProp(item, propName) {\n    if (item.json && typeof item.json === 'object' && propName in item.json) {\n      return item.json[propName];\n    }\n    if (propName in item) {\n      return item[propName];\n    }\n    return null;\n  }\n  // Robustly extracts fileId from Google Drive URL\n  function extractFileIdFromUrl(url) {\n    if (!url) return null;\n    let match = url.match(/file\\/d\\/([a-zA-Z0-9_-]+)/);\n    if (match) return match[1];\n    match = url.match(/id=([a-zA-Z0-9_-]+)/);\n    if (match) return match[1];\n    return null;\n  }\n\n  // --- Draft Identification (using URLs from Notion) ---\n  const drafts = {\n    twitter: { fileId: extractFileIdFromUrl(notionItem.property_twitter_draft_url) },\n    linkedin: { fileId: extractFileIdFromUrl(notionItem.property_linked_in_draft_url) },\n    blog: { fileId: extractFileIdFromUrl(notionItem.property_blog_draft_url) },\n    imageTaskList: { fileId: extractFileIdFromUrl(notionItem.property_image_task_list_url) }\n  };\n\n  // --- Image Identification (using file list from Drive) ---\n  // Acceptable image extensions\n  const validExtensions = ['.jpeg', '.jpg', '.png', '.webp'];\n  // Sort by asset number in file name (asset-<n>)\n  const availableImages = files\n    .map(item => {\n      const name = getProp(item, 'name');\n      const id = getProp(item, 'id');\n      // Must have valid name/id and begin with \"asset-<n>\"\n      if (\n        !name ||\n        !id ||\n        !name.match(/^asset-\\d+-session_/) || // regex matches asset-number-session\n        !validExtensions.some(ext => name.toLowerCase().endsWith(ext))\n      ) {\n        return null;\n      }\n      // Extract asset number robustly\n      const assetMatch = name.match(/^asset-(\\d+)-session_/);\n      if (assetMatch) {\n        return {\n          assetNumber: parseInt(assetMatch[1], 10),\n          fileId: id,\n          fileName: name\n        };\n      }\n      return null;\n    })\n    .filter(img => img !== null)\n    .sort((a, b) => a.assetNumber - b.assetNumber);\n\n  // --- Debugging: Log edge cases to n8n console (viewable in browser logs)\n  console.log('[DEBUG: organize assets] files:', files);\n  console.log('[DEBUG: organize assets] availableImages:', availableImages);\n\n  // --- Final Output ---\n  return [{\n    json: {\n      notionItem,\n      sessionId,\n      assets: {\n        availableImages,\n        drafts\n      }\n    }\n  }];\n} catch (error) {\n  return [{\n    json: {\n      error: true,\n      message: \"Error in Organize Assets: \" + error.message\n    }\n  }];\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4704,
        -592
      ],
      "id": "91cd0cb6-c418-47d3-af1f-308a53b8722f",
      "name": "Organize Assets"
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": {
          "__rl": true,
          "value": "={{ $json.assets.drafts.imageTaskList.fileId }}",
          "mode": "id"
        },
        "options": {}
      },
      "id": "8dd10539-b8c4-451e-b3db-148d2a8cb4bc",
      "name": "Download – Image Task list",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        -4496,
        -880
      ],
      "retryOnFail": true,
      "alwaysOutputData": true,
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "1hcyFpBqSOMDRDna",
          "name": "Google Drive Adude"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// This node creates the definitive list of required images for the session.\ntry {\n    const taskListText = $input.first()?.json?.data;\n    // If the download failed, the input will be empty. This is expected.\n    if (!taskListText) {\n        // This is Scenario 1: No images are required for this content.\n        return [{ json: { expectedImageNumbers: [] } }];\n    }\n    \n    const imageNumbers = [];\n    // Find all instances of \"Asset X\" to determine planned images.\n    const assetMatches = taskListText.matchAll(/Asset (\\d+)/g);\n    for (const match of assetMatches) {\n        imageNumbers.push(parseInt(match[1]));\n    }\n\n    return [{\n        json: {\n            // Return a unique, sorted list of image numbers.\n            expectedImageNumbers: [...new Set(imageNumbers)].sort((a, b) => a - b)\n        }\n    }];\n} catch (error) {\n    return [{ json: { error: true, message: \"Error parsing image manifest: \" + error.message } }];\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4064,
        -880
      ],
      "id": "517b3350-c6c9-449d-b2f3-716ef98e720f",
      "name": "Parse Image Manifest"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -3456,
        -672
      ],
      "id": "1d33dcd3-ac15-4575-97c7-300741f9269c",
      "name": "Loop to Download Images",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": {
          "__rl": true,
          "value": "={{ $json.fileId }}",
          "mode": "id"
        },
        "options": {}
      },
      "id": "a634b885-bbb8-4f25-be7f-8e07a8d6362a",
      "name": "Download Image Binary",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        -3216,
        -656
      ],
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "1hcyFpBqSOMDRDna",
          "name": "Google Drive Adude"
        }
      }
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": {
          "__rl": true,
          "value": "={{ $json.notionItem.property_twitter_draft_url }}",
          "mode": "url"
        },
        "options": {}
      },
      "id": "26fdb157-a7d9-45eb-a74c-0486c70791e7",
      "name": "Download – Twitter Draft",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        -4496,
        -704
      ],
      "retryOnFail": false,
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "1hcyFpBqSOMDRDna",
          "name": "Google Drive Adude"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": {
          "__rl": true,
          "value": "={{ $json.notionItem.property_linked_in_draft_url }}",
          "mode": "url"
        },
        "options": {}
      },
      "id": "07f05b95-4ae7-4913-a0ba-3189da6d5623",
      "name": "Download – LinkedIn Draft",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        -4496,
        -528
      ],
      "retryOnFail": false,
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "1hcyFpBqSOMDRDna",
          "name": "Google Drive Adude"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": {
          "__rl": true,
          "value": "={{ $json.notionItem.property_blog_draft_url }}",
          "mode": "url"
        },
        "options": {}
      },
      "id": "8484a8d9-b500-4c0f-994b-3e14a00bbbd1",
      "name": "Download – Blog Draft",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        -4496,
        -336
      ],
      "retryOnFail": false,
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "1hcyFpBqSOMDRDna",
          "name": "Google Drive Adude"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "operation": "text",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -4288,
        -880
      ],
      "id": "b937bc7f-4797-4d5a-ae9e-85011a895591",
      "name": "Extract from File - ImageTaskList",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "text",
        "destinationKey": "TwitterData",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -4272,
        -704
      ],
      "id": "c9355c6d-6968-4b39-ba3d-f885fca4d5cb",
      "name": "Extract from File - Twitter"
    },
    {
      "parameters": {
        "operation": "text",
        "destinationKey": "LinkedInData",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -4272,
        -528
      ],
      "id": "371e04b9-03c7-4763-9204-e598a5b9e2a4",
      "name": "Extract from File - LinkedIn"
    },
    {
      "parameters": {
        "operation": "text",
        "destinationKey": "BlogData",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -4272,
        -336
      ],
      "id": "ec13165b-7f75-4034-820f-f533159b78aa",
      "name": "Extract from File - Blog"
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -4048,
        -496
      ],
      "id": "1e72ad50-9485-4276-bd3d-4f9ce3a45f9f",
      "name": "Merge - All Text Ready",
      "retryOnFail": true
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -3872,
        -672
      ],
      "id": "762e8184-ce79-4fe0-a4cb-d8d76fd44e7c",
      "name": "Merge - All Assets Ready",
      "retryOnFail": false
    },
    {
      "parameters": {
        "jsCode": "// This node creates a final download queue.\nconst availableImages = $('Organize Assets').first().json.assets.availableImages || [];\n\nreturn availableImages.map(img => ({ json: img }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3680,
        -672
      ],
      "id": "92546aec-1826-4e5a-8ba4-3d122b9d22f4",
      "name": "Code - Prepare Image Downloads"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "a096b267-4bd1-4456-967e-5fb6c886280f",
              "name": "dataReady",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "2dd9f062-c8df-4b7c-9152-9968f289cdfc",
              "name": "twitterDraft",
              "value": "={{ $('Extract from File - Twitter').isExecuted ? $('Extract from File - Twitter').first().json.TwitterData : '' }}",
              "type": "string"
            },
            {
              "id": "37686633-743a-4c7a-a158-df29afad8ffc",
              "name": "linkedinDraft",
              "value": "={{ $('Extract from File - LinkedIn').isExecuted ? $('Extract from File - LinkedIn').first().json.LinkedInData : '' }}",
              "type": "string"
            },
            {
              "id": "9a2f68a9-fa02-44e0-84d4-6f959b216994",
              "name": "blogDraft",
              "value": "={{ $('Extract from File - Blog').isExecuted ? $('Extract from File - Blog').first().json.BlogData : '' }}",
              "type": "string"
            },
            {
              "id": "5d5eff14-59ba-4e64-9826-54ebbbdbc086",
              "name": "expectedImages",
              "value": "={{ $('Parse Image Manifest').first().json.expectedImageNumbers }}",
              "type": "string"
            },
            {
              "id": "b7c37642-57e0-4e1f-9754-3b8edf404332",
              "name": "availableImages",
              "value": "={{ $('Organize Assets').first().json.assets.availableImages }}",
              "type": "string"
            },
            {
              "id": "8de84e43-ad79-472c-8b72-014cd4d957be",
              "name": "notionItem.property_blog_slug",
              "value": "={{ $('Organize Assets').all()[0].json.notionItem.property_blog_slug  }}",
              "type": "string"
            },
            {
              "id": "d5e0f69b-d3dd-406c-8c15-14e816ff688a",
              "name": "notionItem.property_blog_seo_description",
              "value": "={{ $('Organize Assets').all()[0].json.notionItem.property_blog_seo_description || '' }}",
              "type": "string"
            },
            {
              "id": "e476b316-bc71-4111-bbf4-e3df6eaba90f",
              "name": "notionItem.property_blog_seo_keywords",
              "value": "={{ $('Organize Assets').all()[0].json.notionItem.property_blog_seo_keywords || '' }}",
              "type": "string"
            },
            {
              "id": "aca30f87-abc4-4feb-9e56-98a92f69d7ec",
              "name": "notionItem.property_blog_seo_title",
              "value": "={{ $('Organize Assets').all()[0].json.notionItem.property_blog_seo_title || '' }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -3408,
        -352
      ],
      "id": "a9851ecc-31c3-4436-86bb-212064c956f2",
      "name": "Set - All Data Ready",
      "executeOnce": true
    },
    {
      "parameters": {
        "jsCode": "// FINAL DECISION ENGINE V5.0\n// This node analyzes all data and creates a definitive plan for each platform.\ntry {\n  // --- 1. GATHER ALL EVIDENCE ---\n  // All data is now guaranteed to be ready from the \"Set - All Data Ready\" node.\n  const { twitterDraft, linkedinDraft, blogDraft, expectedImages } = $input.first().json;\n\n  // --- 2. EXTRACT MARKERS & BUILD GLOBAL CONTEXT ---\n  // This helper function finds all image markers (e.g., [1, 2]) in a text.\n  const getMarkers = (text) => Array.from(text.matchAll(/<<IMAGE_(\\d+)>>/g), m => parseInt(m[1]));\n  \n  const twitterMarkers = getMarkers(twitterDraft || '');\n  const linkedinMarkers = getMarkers(linkedinDraft || '');\n  const blogMarkers = getMarkers(blogDraft || '');\n\n  // This is the \"global context\"—all markers found across all drafts.\n  const allDiscoveredMarkers = [...new Set([...twitterMarkers, ...linkedinMarkers, ...blogMarkers])];\n  const manifestHasImages = expectedImages && expectedImages.length > 0;\n\n  // --- 3. THE HIERARCHY OF TRUTH (Per Platform) ---\n  // This function decides the image plan for ONE platform.\n  const determineImagePlan = (platformMarkers, isSocialPlatform = false) => {\n    \n    // SCENARIO 3 (Highest Truth): Markers are present in *this* draft.\n    // This is your Rule #3: Obey the markers.\n    if (platformMarkers.length > 0) {\n      return platformMarkers;\n    }\n    \n    // SCENARIO 2 (AI Failure Fallback): This draft has no markers, \n    // but we know images *should* exist (either from other drafts or the manifest).\n    if (allDiscoveredMarkers.length > 0 || manifestHasImages) {\n      if (isSocialPlatform) {\n         // For social (Twitter/LinkedIn), just attach the most important image, Asset 1.\n        return [1];\n      } else {\n        // For the blog, attach all expected images.\n        return expectedImages || [];\n      }\n    }\n    \n    // SCENARIO 1 (No Images Intended): No markers anywhere, manifest is empty.\n    return [];\n  };\n\n  // --- 4. CREATE THE FINAL, UNAMBIGUOUS PLAN ---\n  const finalPlan = {\n    scenario: 'Definitive_Image_Plan_V5.0',\n    twitter: { imageNumbers: determineImagePlan(twitterMarkers, true) },\n    linkedin: { imageNumbers: determineImagePlan(linkedinMarkers, true) },\n    blog: { imageNumbers: determineImagePlan(blogMarkers, false) },\n  };\n\n  // --- 5. CREATE THE MASTER DOWNLOAD LIST ---\n  // This is a small optimization for your \"Prepare Image Downloads\" node.\n  // We can update that node later to only download images that are *actually* needed.\n  finalPlan.allImagesToDownload = [...new Set([\n    ...finalPlan.twitter.imageNumbers,\n    ...finalPlan.linkedin.imageNumbers,\n    ...finalPlan.blog.imageNumbers,\n  ])].sort((a, b) => a - b);\n\n  return [ { json: finalPlan } ];\n\n} catch (error) {\n  return [{ json: { error: true, message: \"Error in Decision Engine: \" + error.message, scenario: 'ERROR' } }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -5600,
        384
      ],
      "id": "217cd488-7193-4ada-94dc-6d505de19fbd",
      "name": "Detect Images Needed vs Present"
    },
    {
      "parameters": {
        "jsCode": "// FINAL ROBUST BLOG PARSER & ATTACHER V9.0\ntry {\n  // --- 1. Gather Data ---\n  const masterData = $('Set - All Data Ready').first().json;\n  const markdownText = masterData.blogDraft;\n  if (!markdownText) throw new Error('Blog draft content is empty.');\n\n  const allCachedImages = $('Loop to Download Images').all(); // Ensure this is correct node!\n  console.log('Image cache:', allCachedImages.map(img => img.json.fileName));\n\n  // Sanity SEO fields\n  const title = masterData.notionItem.property_blog_seo_title || 'Untitled Post';\n  const slug = masterData.notionItem.property_blog_slug || '';\n  const description = masterData.notionItem.property_blog_seo_description || '';\n  const keywords = masterData.notionItem.property_blog_seo_keywords || '';\n  if (!slug) throw new Error('BlogSlug property missing.');\n\n  // --- 2. Split Markdown Into Blocks (text + image tags)\n  // Regex splits at every <<IMAGE_x>>\n  const blockPattern = /<<IMAGE_(\\d+)>>/g;\n  let lastIdx = 0;\n  let match;\n  let blocks = [];\n\n  while ((match = blockPattern.exec(markdownText)) !== null) {\n    // Text before this image tag\n    if (match.index > lastIdx) {\n      blocks.push({ type: 'text', content: markdownText.slice(lastIdx, match.index) });\n    }\n    // Image block for this marker\n    blocks.push({ type: 'image', imageNumber: parseInt(match[1]), marker: match[0] });\n    lastIdx = blockPattern.lastIndex;\n  }\n  // Any trailing text after last marker\n  if (lastIdx < markdownText.length) {\n    blocks.push({ type: 'text', content: markdownText.slice(lastIdx) });\n  }\n\n  // --- 3. Process Blocks and Attach Images\n  let outputBlocks = [];\n  blocks.forEach(block => {\n    if (block.type === 'text') {\n      // Only push non-empty blocks\n      if (block.content && block.content.trim().length > 0) {\n        outputBlocks.push({ type: 'text', content: block.content.trim() });\n      }\n    } else if (block.type === 'image') {\n      // Find the correct cached image\n      const targetImage = allCachedImages.find(\n        img => typeof img.json.fileName === 'string' && img.json.fileName.includes(`asset-${block.imageNumber}`)\n      );\n      if (!targetImage) {\n        throw new Error(`Blog Image asset-${block.imageNumber} missing in cache for marker ${block.marker}`);\n      }\n      outputBlocks.push({ \n        type: 'image', \n        marker: block.marker, // For debugging\n        imageNumber: block.imageNumber,\n        binary: targetImage.binary\n      });\n    }\n  });\n\n  // --- 4. Optional: Attach SEO/meta info for Sanity\n  return [{\n    json: {\n      title,\n      slug,\n      description,\n      keywords: keywords.split(',').map(k => k.trim()),\n      blocks: outputBlocks // This is the key array for posting!\n    }\n  }];\n\n} catch (error) {\n  return [{ json: { error: true, message: `[Blog Parse]: ${error.message}` } }];\n}\n"
      },
      "id": "44ba74fb-4f0f-42b3-bfd7-9b8ede95ca9c",
      "name": "Code - Parse Blog Content",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4880,
        -48
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://ero5c9mt.api.sanity.io/v2021-06-07/assets/images/production",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBearerAuth",
        "sendBody": true,
        "contentType": "binaryData",
        "inputDataFieldName": "imageBinary",
        "options": {
          "response": {
            "response": {
              "fullResponse": true
            }
          }
        }
      },
      "id": "0b255009-abaf-417e-9008-6ea8e53e2457",
      "name": "Upload Image to Sanity",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -4208,
        48
      ],
      "credentials": {
        "httpBearerAuth": {
          "id": "apbyWqfBZDKKduxM",
          "name": "Sanity API Token"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://ero5c9mt.api.sanity.io/v2021-06-07/data/mutate/production",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBearerAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {
          "response": {
            "response": {
              "fullResponse": true
            }
          }
        }
      },
      "id": "d4db88d5-b168-4e3f-bda7-ab0ce4cba1e1",
      "name": "POST Blog to Sanity",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -3760,
        -144
      ],
      "credentials": {
        "httpBearerAuth": {
          "id": "apbyWqfBZDKKduxM",
          "name": "Sanity API Token"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "try {\n  // Get data from the previous node\n  const data_node = $('Set - All Data Ready').first().json;\n  const markdownText = data_node.twitterDraft;\n  \n  // Get the image cache, which is now 100% ready.\n  const allCachedImages = $('Loop to Download Images').all();\n  \n  // Split by \"Tweet X/Y\" pattern to separate individual tweets\n  // The regex captures \"Tweet 1/4\", \"Tweet 2/4\", etc.\n  const tweetBlocks = markdownText.match(/\\d+\\/\\d+[\\s\\S]*?(?=\\n\\n---\\n\\nTweet \\d+\\/\\d+|\\n\\n---\\n\\n$|$)/g);\n  \n  if (!tweetBlocks) throw new Error('No tweet blocks found in Twitter draft.');\n  \n  const tweets = tweetBlocks.map((block, index) => {\n    // Extract the tweet number from \"Tweet X/Y\"\n    const markerMatch = block.match(/(Tweet \\d+\\/\\d+)/);\n    const marker = markerMatch ? markerMatch[1] : null;\n    \n    // Find image placeholders like <<IMAGE_1>>\n    const imageMatch = block.match(/<<IMAGE_(\\d+)>>/);\n    let imageBinary = null;\n    \n    if (imageMatch) {\n      const imageNumber = parseInt(imageMatch[1]);\n      const targetImage = allCachedImages.find(img => \n        img.json.fileName.includes(`asset-${imageNumber}-`)\n      );\n      \n      if (!targetImage) {\n        // This will cause the workflow to fail and retry, as you requested.\n        throw new Error(`Image asset-${imageNumber} was required but not found in cache.`);\n      }\n      \n      imageBinary = targetImage.binary.data;\n    }\n    \n    // Clean the text: remove the marker, image placeholder, and \"---\" separators\n    const cleanText = block\n      .replace(/Tweet \\d+\\/\\d+/, '')  // Remove \"Tweet X/Y\"\n      .replace(/<<IMAGE_\\d+>>/, '')    // Remove image placeholders\n      .replace(/\\n\\n---\\n\\n$/, '')    // Remove trailing separator\n      .replace(/^\\n+/, '')             // Remove leading newlines\n      .replace(/\\n+$/, '')             // Remove trailing newlines\n      .replace(/^(Tweet\\s+)?\\d+\\/\\d+\\s*\\n*/mi, '')  // Remove \"Tweet X/Y\" or just \"X/Y\"\n      .trim();\n    \n    return {\n      json: {\n        order: index + 1,\n        text: cleanText,\n        inReplyTo: index > 0,\n        imageBinary: imageBinary\n      }\n    };\n  });\n  \n  return tweets;\n} catch (error) {\n  return [{ json: { error: true, message: `[Twitter Parse]: ${error.message}` } }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4864,
        992
      ],
      "id": "0b22bb65-d2d3-4bad-8388-488312a2f1e1",
      "name": "Code - Parse & Attach Tweets"
    },
    {
      "parameters": {
        "text": "={{ $json.text }}",
        "additionalFields": {
          "attachments": "={{ $json.media_id_string }}"
        }
      },
      "type": "n8n-nodes-base.twitter",
      "typeVersion": 2,
      "position": [
        -3072,
        800
      ],
      "id": "9131c094-6756-4a9b-8da5-d3edb7de8b7d",
      "name": "Create Tweet",
      "retryOnFail": false,
      "waitBetweenTries": 5000,
      "alwaysOutputData": false,
      "maxTries": 5,
      "credentials": {
        "twitterOAuth2Api": {
          "id": "KgoQ7hy5adHEKxP8",
          "name": "X Main account - _AmanSurya BIP"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -4640,
        992
      ],
      "id": "bcccbbf1-419a-4555-9c1a-5c0084b8f05e",
      "name": "SplitInBatches - Loop Tweets"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://upload.twitter.com/1.1/media/upload.json",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "twitterOAuth1Api",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "media",
              "inputDataFieldName": "imageBinary"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -3968,
        752
      ],
      "id": "981f63cb-4ef5-4983-a068-69946b416b90",
      "name": "Upload Media to Twitter",
      "credentials": {
        "twitterOAuth1Api": {
          "id": "jXvbly02NqW5WcTI",
          "name": "X OAuth Main account - _AmanSurya BIP"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// FINAL BINARY DATA PREPARATION FOR TWITTER UPLOAD\n// This node flattens the nested binary structure for the HTTP Request node.\ntry {\n  const tweetData = $input.first().json;\n\n  // Extract the actual binary data from the nested structure\nconst actualBinary = tweetData.imageBinary;\n\n\n  // Return the tweet data with the binary at the correct level\n  return [{\n    json: {\n      text: tweetData.text,\n      inReplyTo: tweetData.inReplyTo,\n      order: tweetData.order\n    },\n    binary: {\n      // This is the key - we're putting the binary data at the top level\n      imageBinary: actualBinary\n    }\n  }];\n\n} catch (error) {\n  return [{\n    json: {\n      error: true,\n      message: `[Prepare Binary for Upload]: ${error.message}`\n    }\n  }];\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4192,
        752
      ],
      "id": "80cf5cd6-5350-4ba6-8074-d7bb1803adad",
      "name": "Prepare Binary for Upload"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "35a1052d-9e1e-4099-ad8c-865729382f75",
              "leftValue": "={{ $json.imageBinary }}",
              "rightValue": "",
              "operator": {
                "type": "object",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -4416,
        928
      ],
      "id": "53531328-4e89-4db3-9f06-685d8b0a6b95",
      "name": "IF - Image Exists?"
    },
    {
      "parameters": {
        "jsCode": "// UNIFIED TWEET PREPARATION - CORRECTED FOR FLAT DATA STRUCTURE\n// Input comes directly from IF node (no Set nodes)\ntry {\n  const input = $input.first().json;\n  \n  // Extract text directly - it's already a string from the IF node\n  const text = $('SplitInBatches - Loop Tweets').first().json.text|| \"\";\n  \n  // Extract media_id_string if it exists (from image path via Upload Media)\n  // If coming from false path (text-only), media_id_string won't exist\n  const media_id_string = input.media_id_string || \"\";\n  \n  // Extract inReplyTo flag\n  const inReplyTo = $('SplitInBatches - Loop Tweets').first().json.inReplyTo || false;\n  \n  // Extract order\n  const order = $('SplitInBatches - Loop Tweets').first().json.order || 0;\n  \n  // Return the flat, clean structure\n  return [{\n    json: {\n      text: text,\n      media_id_string: media_id_string,\n      inReplyTo: inReplyTo,\n      order: order\n    }\n  }];\n  \n} catch (error) {\n  return [{\n    json: {\n      error: true,\n      message: `[Unified Prep]: ${error.message}`,\n      text: input?.text || \"Error preparing tweet\",\n      media_id_string: \"\",\n      inReplyTo: false,\n      order: 0\n    }\n  }];\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3744,
        928
      ],
      "id": "3c61e69a-9f78-4b84-b20a-2bf5acf03f57",
      "name": "Code - Unified Tweet Preparation"
    },
    {
      "parameters": {
        "jsCode": "// ============================================================\n// ADD PARENT TWEET ID - WITH ID CLEANING\n// ============================================================\n\ntry {\n  const tweetData = $input.first()?.json || {};\n  const order = tweetData.order || 1;\n  \n  console.log(`[Threading] ========================================`);\n  console.log(`[Threading] Processing tweet ${order}`);\n  \n  let parentTweetId = null;\n  let isFirstTweet = false;\n  \n  // ============================================================\n  // CASE 1: First Tweet (order === 1)\n  // ============================================================\n  if (order === 1) {\n    console.log(`[Threading] ✓ Tweet ${order}: FIRST TWEET`);\n    parentTweetId = null;\n    isFirstTweet = true;\n    \n    return [{\n      json: {\n        text: tweetData.text,\n        media_id_string: tweetData.media_id_string || \"\",\n        inReplyTo: tweetData.inReplyTo || false,\n        order: order,\n        parentTweetId: parentTweetId,\n        isFirstTweet: isFirstTweet\n      }\n    }];\n  }\n  \n  // ============================================================\n  // CASE 2: Subsequent Tweets (order > 1)\n  // ============================================================\n  if (order > 1 && tweetData.inReplyTo === true) {\n    console.log(`[Threading] → Tweet ${order}: Getting parent tweet ID...`);\n    \n    try {\n      const prepareNode = $('Prepare for Next Loop').first()?.json;\n      console.log(`[Threading] Raw lastTweetId:`, prepareNode?.lastTweetId);\n      console.log(`[Threading] Type:`, typeof prepareNode?.lastTweetId);\n      \n      if (prepareNode?.lastTweetId) {\n        // CRITICAL FIX: Clean the tweet ID thoroughly\n        const rawId = prepareNode.lastTweetId;\n        \n        // Convert to string and remove all unwanted characters\n        parentTweetId = String(rawId)\n          .replace(/[\"\\t\\n\\r\\\\]/g, '')  // Remove quotes, tabs, newlines, backslashes\n          .replace(/\\s+/g, '')           // Remove all whitespace\n          .trim();                       // Trim edges\n        \n        console.log(`[Threading] ✓ Cleaned parent tweet ID: ${parentTweetId}`);\n        console.log(`[Threading] ✓ Length: ${parentTweetId.length}`);\n        console.log(`[Threading] ✓ Is numeric: ${/^[0-9]+$/.test(parentTweetId)}`);\n        \n        // Validate it's a valid tweet ID (numeric, 1-19 digits)\n        if (!/^[0-9]{1,19}$/.test(parentTweetId)) {\n          console.error(`[Threading] ✗ Invalid tweet ID format after cleaning!`);\n          console.error(`[Threading] Cleaned ID: \"${parentTweetId}\"`);\n          console.error(`[Threading] Character codes:`, Array.from(parentTweetId).map(c => c.charCodeAt(0)));\n          parentTweetId = null;\n        }\n      } else {\n        console.error(`[Threading] ✗ No lastTweetId found`);\n      }\n    } catch (error) {\n      console.error(`[Threading] ✗ Error:`, error.message);\n    }\n    \n    isFirstTweet = false;\n    \n    if (!parentTweetId) {\n      console.error(`[Threading] ✗✗✗ CRITICAL ERROR ✗✗✗`);\n      console.error(`[Threading] No valid parent tweet ID for tweet ${order}`);\n      \n      return [{\n        json: {\n          text: tweetData.text,\n          media_id_string: tweetData.media_id_string || \"\",\n          inReplyTo: tweetData.inReplyTo,\n          order: order,\n          parentTweetId: null,\n          isFirstTweet: false,\n          error: true,\n          errorMessage: `Cannot find valid parent tweet ID for tweet ${order}`,\n          errorType: 'MISSING_PARENT_ID'\n        }\n      }];\n    }\n    \n    console.log(`[Threading] ✓ Tweet ${order} will reply to: ${parentTweetId}`);\n  }\n  \n  // ============================================================\n  // CASE 3: Non-reply tweet\n  // ============================================================\n  else if (tweetData.inReplyTo === false) {\n    console.log(`[Threading] → Tweet ${order}: Standalone tweet`);\n    parentTweetId = null;\n    isFirstTweet = (order === 1);\n  }\n  \n  console.log(`[Threading] ✓ Final output - isFirstTweet: ${isFirstTweet}, parentTweetId: ${parentTweetId || 'null'}`);\n  console.log(`[Threading] ========================================`);\n  \n  return [{\n    json: {\n      text: tweetData.text,\n      media_id_string: tweetData.media_id_string || \"\",\n      inReplyTo: tweetData.inReplyTo,\n      order: order,\n      parentTweetId: parentTweetId,\n      isFirstTweet: isFirstTweet\n    }\n  }];\n  \n} catch (error) {\n  console.error(`[Threading] ✗ EXCEPTION:`, error.message);\n  \n  const inputData = $input.first()?.json || {};\n  \n  return [{\n    json: {\n      text: inputData.text || \"\",\n      media_id_string: inputData.media_id_string || \"\",\n      inReplyTo: inputData.inReplyTo || false,\n      order: inputData.order || 1,\n      parentTweetId: null,\n      isFirstTweet: (inputData.order === 1),\n      error: true,\n      errorMessage: `Exception: ${error.message}`,\n      errorType: 'EXCEPTION'\n    }\n  }];\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3520,
        928
      ],
      "id": "dce802be-feb8-4317-9b11-b5132331b7bb",
      "name": "Code - Add Parent Tweet ID"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "ccf1adf1-54d6-463c-8ee5-b0703c3d3254",
              "leftValue": "={{ $json.isFirstTweet }}",
              "rightValue": "true",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": "",
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -3296,
        928
      ],
      "id": "ef40be48-2ea0-4253-9fdc-a496c76cdc67",
      "name": "IF - Is This First Tweet?"
    },
    {
      "parameters": {
        "text": "={{ $json.text }}",
        "additionalFields": {
          "attachments": "={{ $json.media_id_string }}",
          "inReplyToStatusId": {
            "__rl": true,
            "value": "={{ $json.parentTweetId }}",
            "mode": "id"
          }
        }
      },
      "type": "n8n-nodes-base.twitter",
      "typeVersion": 2,
      "position": [
        -3072,
        992
      ],
      "id": "4ff03625-0c1b-4ac3-8905-3c98f4de7a81",
      "name": "Create Tweet Reply",
      "retryOnFail": false,
      "maxTries": 5,
      "waitBetweenTries": 5000,
      "credentials": {
        "twitterOAuth2Api": {
          "id": "KgoQ7hy5adHEKxP8",
          "name": "X Main account - _AmanSurya BIP"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -2848,
        928
      ],
      "id": "38f18428-95e8-466c-9563-4e9a32e74de3",
      "name": "Merge1"
    },
    {
      "parameters": {
        "jsCode": "// Code - Prepare Image Uploads\ntry {\n  const blogData = $input.first().json;\n  // Filter out all image blocks\n  const imageBlocks = blogData.blocks.filter(b => b.type === 'image' && b.binary);\n  // Prepare items for upload: put binary at top-level\n  return imageBlocks.map(img => ({\n    json: {\n      marker: img.marker,\n      imageNumber: img.imageNumber,\n      alt: img.alt || 'Blog image',          // fallback alt\n      caption: img.caption || '',            // optional\n      fileName: img.binary.data.fileName\n    },\n    binary: {\n      imageBinary: img.binary.data           // flatten actual binary\n    }\n  }));\n} catch (error) {\n  return [{json: {error: true, message: `[Prepare Image Uploads]: ${error.message}`}}];\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4656,
        -48
      ],
      "id": "8ee966db-d7a6-44af-80ba-3ba0182cedd6",
      "name": "Prepare Image"
    },
    {
      "parameters": {
        "jsCode": "// --- FINAL PRODUCTION V12.0 ---\n// DEPLOYMENT-READY, HIGH-PERFORMANCE PARSER\n//\n// AUTHOR: Gemini\n// DATE: 2025-11-08\n//\n// V12.0 CHANGELOG:\n// - CRITICAL FIX (Headings): Rewrote 'detectHeadingLevel'.\n//   - It now correctly handles text with or without a space (e.g., \"##Heading\" vs \"## Heading\").\n//   - It now *guarantees* the removal of all hash prefixes from the returned text.\n//\n// - CRITICAL FIX (Lists): Rewrote 'isListItem' and 'cleanListItemText'.\n//   - 'isListItem' is now more robust and correctly identifies list items, even with leading spaces.\n//   - 'cleanListItemText' is updated to perfectly mirror 'isListItem', ensuring the bullet/number\n//     is stripped *before* 'parseInlineFormatting' is called.\n//   - This prevents the 'currentParagraph' bug that was mangling your lists.\n//\n// - KEPT (V11 Fixes):\n//   - The high-performance 'parseInlineFormatting' tokenizer (to prevent timeouts).\n//   - The 'pre-cleaning' step (to fix the '```markdown' wrapper bug).\n// ---\n\ntry {\n  // --- 1. Get Data ---\n\n  // Get the parsed blocks from 'Code - Parse Blog Content'\n  const blogData = $('Code - Parse Blog Content').first().json;\n\n  // Get the map of uploaded images\n  let imageMap;\n  if ($input.all().length > 0 && $input.first().json.marker) {\n    imageMap = $input.all();\n  } else {\n    // Fallback if the input is empty (e.g., text-only post)\n    imageMap = $('Code - Build Image Reference Map').all() || [];\n  }\n\n  console.log('Blog blocks (raw):', blogData.blocks.length, 'Images:', imageMap.length);\n\n  // --- 2. PRE-CLEANING STEP (FIX FOR '```markdown' BUG) ---\n  if (blogData.blocks && blogData.blocks.length > 0) {\n    // Clean the FIRST block\n    const firstBlock = blogData.blocks[0];\n    if (firstBlock.type === 'text' && firstBlock.content) {\n      firstBlock.content = firstBlock.content.trimStart().replace(/^```(markdown|md)?\\s*/, '');\n    }\n    // Clean the LAST block\n    const lastBlock = blogData.blocks[blogData.blocks.length - 1];\n    if (lastBlock.type === 'text' && lastBlock.content) {\n      lastBlock.content = lastBlock.content.trimEnd().replace(/```$/, '');\n    }\n  }\n\n  // --- 3. High-Performance Helper Functions (V12) ---\n\n  const BACKTICK = String.fromCharCode(96);\n  const CODE_FENCE = BACKTICK + BACKTICK + BACKTICK;\n\n  // Finds the uploaded image asset ID from the map\n  function getAssetForMarker(marker) {\n    if (!imageMap || imageMap.length === 0) return null;\n    const found = imageMap.find(m => m.json && m.json.marker === marker);\n    return found ? found.json : null;\n  }\n\n  // Checks if a text block is a fenced code block\n  function isCodeBlock(text) {\n    if (!text || typeof text !== 'string') return false;\n    return text.trim().startsWith(CODE_FENCE);\n  }\n\n  // Parses a fenced code block\n  function parseCodeBlock(text) {\n    if (!text || typeof text !== 'string') return { language: 'text', code: '' };\n    const lines = text.trim().split('\\n');\n    const firstLine = lines[0] || '';\n    const language = firstLine.replace(CODE_FENCE, '').trim() || 'text';\n    const code = lines.slice(1, -1).join('\\n');\n    return { language, code };\n  }\n\n  // --- (FIX V12.0: LISTS) ---\n  // More robust check for list items. Allows optional leading whitespace.\n  function isListItem(text) {\n    if (!text || typeof text !== 'string') return false;\n    const trimmed = text.trim();\n    // Matches '  * item' or '1. item'\n    return /^\\s*[*\\-]\\s+/.test(trimmed) || /^\\s*\\d+[\\.\\)]\\s+/.test(trimmed);\n  }\n\n  // --- (FIX V12.0: LISTS) ---\n  // Mirrors 'isListItem' to perfectly clean the text.\n  function cleanListItemText(text) {\n    if (!text || typeof text !== 'string') return '';\n    const trimmed = text.trim();\n    // Replaces '  * item' with 'item'\n    return trimmed.replace(/^\\s*[*\\-]\\s+/, '').replace(/^\\s*\\d+[\\.\\)]\\s+/, '').trim();\n  }\n\n  // Detects the list type for Sanity\n  function detectListType(text) {\n    if (!text || typeof text !== 'string') return null;\n    const trimmed = text.trim();\n    if (/^\\s*\\d+[\\.\\)]\\s+/.test(trimmed)) return 'number';\n    if (/^\\s*[*\\-]\\s+/.test(trimmed)) return 'bullet';\n    return null;\n  }\n  // --- (END LIST FIX V12.0) ---\n\n\n  // --- (CRITICAL FIX V11.0: TIMEOUTS) ---\n  // High-performance, non-blocking tokenizer for inline formatting.\n  function parseInlineFormatting(text) {\n    if (!text || typeof text !== 'string') {\n        return [{ _type: 'span', text: String(text || '') }];\n    }\n    \n    // Split by all known delimiters, keeping the delimiters in the array\n    const tokens = text.split(/(\\*\\*|__|\\*|_|`)/g);\n    const children = [];\n    let i = 0;\n\n    while (i < tokens.length) {\n        const token = tokens[i];\n\n        if (!token) { // Handle empty strings from split\n            i++;\n            continue;\n        }\n\n        let mark = null;\n        if (token === '**' || token === '__') mark = 'strong';\n        else if (token === '*' || token === '_') mark = 'em';\n        else if (token === '`') mark = 'code';\n\n        // Check for a valid 3-part marked span: [delimiter, content, delimiter]\n        if (mark && tokens[i+1] && tokens[i+2] === token) {\n            // Found a valid marked span\n            children.push({\n                _type: 'span',\n                text: tokens[i+1], // The content\n                marks: [mark]\n            });\n            i += 3; // Consume all 3 tokens (e.g., '**', 'bold', '**')\n        } else {\n            // Not a valid mark, or just plain text\n            children.push({\n                _type: 'span',\n                text: token,\n                marks: [] // No marks\n            });\n            i++;\n        }\n    }\n    return children;\n  }\n  // --- (END CRITICAL FIX V11.0) ---\n\n\n  // Parses a block of list items\n  function parseListItems(items) {\n    return items.map(item => {\n      // Use the V12 cleaned text\n      const cleanText = cleanListItemText(item); \n      const listType = detectListType(item);\n      \n      return {\n        _type: 'block',\n        style: 'normal',\n        listItem: listType,\n        level: 1, // Required by Sanity\n        // Parse *after* cleaning\n        children: parseInlineFormatting(cleanText), \n        markDefs: []\n      };\n    });\n  }\n\n  // --- (FIX V12.0: HEADINGS) ---\n  // More robust heading detection.\n  // Handles '#Heading' and '# Heading' and cleans both.\n  function detectHeadingLevel(text) {\n    if (!text || typeof text !== 'string') return null;\n    const trimmed = text.trim();\n    \n    // Use 'startsWith' for detection, but 'replace' for cleaning\n    if (trimmed.startsWith('####')) return { level: 'h4', text: trimmed.replace(/^####\\s*/, '').trim() };\n    if (trimmed.startsWith('###')) return { level: 'h3', text: trimmed.replace(/^###\\s*/, '').trim() };\n    if (trimmed.startsWith('##')) return { level: 'h2', text: trimmed.replace(/^##\\s*/, '').trim() };\n    if (trimmed.startsWith('#')) return { level: 'h1', text: trimmed.replace(/^#\\s*/, '').trim() };\n    return null;\n  }\n  // --- (END HEADING FIX V12.0) ---\n\n\n  // --- 4. Main Parsing Logic (Unchanged from V11) ---\n  // This logic is now correct because the helper functions it calls are fixed.\n  const finalBlocks = [];\n  const codeBlockPattern = new RegExp('(' + CODE_FENCE + '[\\\\s\\\\S]*?' + CODE_FENCE + ')', 'g');\n  \n  for (const block of blogData.blocks) {\n    if (block.type === 'text') {\n      const parts = block.content.split(codeBlockPattern);\n      \n      for (const part of parts) {\n        if (!part || !part.trim()) continue;\n        \n        if (isCodeBlock(part)) {\n          // This is a fenced code block\n          const parsed = parseCodeBlock(part);\n          finalBlocks.push({\n            _type: 'code',\n            language: parsed.language,\n            code: parsed.code\n          });\n        } else {\n          // This is regular paragraph/list/heading text\n          const lines = part.split('\\n');\n          let currentParagraph = [];\n          let currentListItems = [];\n          \n          for (let i = 0; i < lines.length; i++) {\n            const line = lines[i];\n            const trimmed = line.trim();\n            \n            if (!trimmed) { // Empty line\n              // Flush list if one was active\n              if (currentListItems.length > 0) {\n                finalBlocks.push(...parseListItems(currentListItems));\n                currentListItems = [];\n              }\n              // Flush paragraph if one was active\n              if (currentParagraph.length > 0) {\n                const paraText = currentParagraph.join(' ').trim();\n                // Check for '---' horizontal rule\n                if (paraText && !/^(---|___|\\\\*\\\\*\\\\*)$/.test(paraText)) {\n                  // CALLS V12 HEADING FIX\n                  const heading = detectHeadingLevel(paraText); \n                  if (heading) {\n                    finalBlocks.push({\n                      _type: 'block',\n                      style: heading.level,\n                      // 'heading.text' is now guaranteed clean\n                      children: parseInlineFormatting(heading.text), \n                      markDefs: []\n                    });\n                  } else {\n                    finalBlocks.push({\n                      _type: 'block',\n                      style: 'normal',\n                      children: parseInlineFormatting(paraText),\n                      markDefs: []\n                    });\n                  }\n                }\n                currentParagraph = [];\n              }\n              continue;\n            }\n            \n            // CALLS V12 LIST FIX\n            if (isListItem(trimmed)) { \n              // Flush paragraph if switching to list\n              if (currentParagraph.length > 0) {\n                const paraText = currentParagraph.join(' ').trim();\n                if (paraText) {\n                    // CALLS V12 HEADING FIX\n                    const heading = detectHeadingLevel(paraText); \n                    if (heading) {\n                      finalBlocks.push({ _type: 'block', style: heading.level, children: parseInlineFormatting(heading.text), markDefs: [] });\n                    } else {\n                      finalBlocks.push({ _type: 'block', style: 'normal', children: parseInlineFormatting(paraText), markDefs: [] });\n                    }\n                }\n                currentParagraph = [];\n              }\n              currentListItems.push(trimmed);\n            } else {\n              // Flush list if switching to paragraph\n              if (currentListItems.length > 0) {\n                finalBlocks.push(...parseListItems(currentListItems));\n                currentListItems = [];\n              }\n              currentParagraph.push(trimmed);\n            }\n          }\n          \n          // Final flush at end of part\n          if (currentListItems.length > 0) {\n            finalBlocks.push(...parseListItems(currentListItems));\n          }\n          if (currentParagraph.length > 0) {\n            const paraText = currentParagraph.join(' ').trim();\n            if (paraText && !/^(---|___|\\\\*\\\\*\\\\*)$/.test(paraText)) {\n              // CALLS V12 HEADING FIX\n              const heading = detectHeadingLevel(paraText); \n              if (heading) {\n                finalBlocks.push({ _type: 'block', style: heading.level, children: parseInlineFormatting(heading.text), markDefs: [] });\n              } else {\n                finalBlocks.push({ _type: 'block', style: 'normal', children: parseInlineFormatting(paraText), markDefs: [] });\n              }\n            }\n          }\n        }\n      }\n    } else if (block.type === 'image') {\n      // This is an image block\n      const assetEntry = getAssetForMarker(block.marker);\n      if (!assetEntry) {\n        // Don't throw error, just log it.\n        console.warn('Image ' + block.marker + ' was defined in markdown but not found in imageMap');\n      } else {\n        finalBlocks.push({\n          _type: 'image',\n          asset: { _type: 'reference', _ref: assetEntry.assetId },\n          alt: assetEntry.alt || 'Blog image',\n          caption: assetEntry.caption || ''\n        });\n      }\n    }\n  }\n\n  // --- 5. Final Mutation Assembly (Unchanged) ---\n  const mutation = {\n    mutations: [{\n      create: {\n        _type: \"post\",\n        title: blogData.title,\n        slug: { _type: \"slug\", current: blogData.slug },\n        status: \"published\", // or \"draft\"\n        excerpt: blogData.description.slice(0, 160),\n        seoTitle: blogData.title.slice(0, 60),\n        seoDescription: blogData.description.slice(0, 160),\n        tags: blogData.keywords || [],\n        publishedAt: new Date().toISOString(),\n        viewCount: 0,\n        body: finalBlocks\n      }\n    }]\n  };\n\n  console.log('Final Sanity blocks generated:', finalBlocks.length);\n  return [{ json: mutation }];\n  \n} catch (error) {\n  console.error('[CRITICAL: Build PT Mutation]', error);\n  // Return detailed error for easier debugging in n8n\n  return [{ json: { error: true, message: '[Build PT Mutation]: ' + error.message, stack: error.stack } }];\n}"
      },
      "id": "a8191666-d35a-4063-a117-e7f9875f7adc",
      "name": "Code - Rebuild Blog Blocks with Image References",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3984,
        -144
      ]
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -4432,
        -48
      ],
      "id": "e7f3df0a-8523-4842-b707-bf3fdd94c2f3",
      "name": "Loop Over Images"
    },
    {
      "parameters": {
        "jsCode": "// Code - Build Uploaded Image Map (CORRECTED)\ntry {\n  // Get all uploaded image responses from Sanity\n  const uploads = $input.all();\n  \n  // Get original image metadata from \"Prepare Image\" node\n  const preparedImages = $('Prepare Image').all();\n  \n  // Build map by matching fileName or imageNumber\n  return uploads.map((upload, index) => {\n    const originalMeta = preparedImages[index]; // Match by order/index\n    \n    return {\n      marker: originalMeta.json.marker,           // <<IMAGE_1>>\n      imageNumber: originalMeta.json.imageNumber, // 1, 2, 3\n      assetId: upload.json.body.document._id,     // from Sanity upload response\n      alt: originalMeta.json.alt,                 // \"Blog image\"\n      caption: originalMeta.json.caption          // \"\"\n    };\n  });\n} catch (error) {\n  return [{json: {error: true, message: `[Build Image Map]: ${error.message}`}}];\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4208,
        -144
      ],
      "id": "0426a000-c12e-4b82-a79b-02a2f61aa9b0",
      "name": "Code - Build Image Reference Map"
    },
    {
      "parameters": {
        "content": "## 1. **Content Retrieval** (3 nodes)\n   - Notion: Get content marked \"Approved\"\n   - Extract folder details and session ID\n   - Google Drive: List all files in session folder\n\n",
        "height": 288,
        "width": 1040
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -5632,
        -720
      ],
      "typeVersion": 1,
      "id": "4a2e36f1-89bc-402c-9743-893326b6a903",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "content": "## => Download all the Social Drafts & Image TaskList",
        "height": 912,
        "width": 384,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -4544,
        -1104
      ],
      "typeVersion": 1,
      "id": "2c916dbd-88b0-4419-861e-0bb059ce63c8",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "content": "## => Download image binary & storing\n## 5. **Decision Engine** (1 node)\n   - Detect needed vs. available images\n   - Execute hierarchy logic\n## 6. **Image Download & Processing** (2 nodes)\n   - Prepare downloads list\n   - Batch download images",
        "height": 448,
        "width": 656,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -3728,
        -912
      ],
      "typeVersion": 1,
      "id": "440dc834-7c10-421f-8fc2-96fdc12c7b93",
      "name": "Sticky Note2"
    },
    {
      "parameters": {
        "content": "## 7. **Arrange all the Drafts & the images if any in proper format**",
        "height": 224,
        "width": 368,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -3536,
        -432
      ],
      "typeVersion": 1,
      "id": "804ddfc8-a736-4f30-ae00-ba94c02551fe",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "content": "## 8. **Blog Publishing Branch** (7 nodes)\n   - Format for Sanity CMS structure\n   - API publishing with metadata\n   - Extract blog URL\n   - Image embedding with alt text\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "height": 400,
        "width": 1568,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -5200,
        -160
      ],
      "typeVersion": 1,
      "id": "da934d00-f8b3-44c2-b4d1-08311f61595f",
      "name": "Sticky Note4"
    },
    {
      "parameters": {
        "content": "## 9. **LinkedIn Publishing Branch** (5 nodes with Error Handling)\n   - Format for LinkedIn\n   - OAuth2 authenticated posting\n   - Extract post URL\n   - Timeout/rate limit recovery",
        "height": 448,
        "width": 1600,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -5200,
        256
      ],
      "typeVersion": 1,
      "id": "ab54cb75-47c5-416b-8815-923d923ac504",
      "name": "Sticky Note5"
    },
    {
      "parameters": {
        "content": "## 10. **Twitter Branch Publishing** (12 nodes with Error Handling)\n   - Format Twitter thread (4 tweets max)\n   - OAuth2 authenticated posting\n   - Extract tweet IDs\n   - Build thread structure\n   - Exponential backoff retry logic",
        "height": 448,
        "width": 2704,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -5200,
        704
      ],
      "typeVersion": 1,
      "id": "4f36b118-1636-43fc-8e14-85b012e8cd61",
      "name": "Sticky Note6"
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -3200,
        288
      ],
      "id": "23933bb0-4330-4f89-ba79-0c363440396b",
      "name": "Merge"
    },
    {
      "parameters": {
        "resource": "databasePage",
        "operation": "update",
        "pageId": {
          "__rl": true,
          "value": "={{ $('Notion – Get Approved').all()[0].json.id }}",
          "mode": "id"
        },
        "propertiesUi": {
          "propertyValues": [
            {
              "key": "PostedAt|date",
              "date": "={{ $now.setZone('Asia/Kolkata').toISO() }}",
              "timezone": "Asia/Calcutta"
            },
            {
              "key": "Post Status|multi_select",
              "multiSelectValue": "={{ \n  (() => {\n    const statuses = [];\n    const items = $input.all().map(i => i.json);\n    \n    // Check for LinkedIn success (has 'urn' field)\n    const linkedinPosted = items.some(item => item.urn && !item.skipped);\n    if (linkedinPosted) {\n      statuses.push('Posted at LinkedIn');\n    }\n    \n    // Check for Twitter/X success (has 'lastTweetId' field)\n    const twitterPosted = items.some(item => item.lastTweetId && !item.skipped);\n    if (twitterPosted) {\n      statuses.push('Posted at X');\n    }\n    \n    // Check for Blog success (has 'platform' === 'blog' and NOT skipped)\n    const blogPosted = items.some(item => item.platform === 'blog' && item.success === true && !item.skipped);\n    if (blogPosted) {\n      statuses.push('Posted as blog at site');\n    }\n    \n    return statuses;\n  })()\n}}"
            },
            {
              "key": "Status|select",
              "selectValue": "={{ \n  (() => {\n    const notionItem = $('Notion – Get Approved').all()[0].json;\n    const postTo = notionItem.properties?.PostTo?.multi_select || [];\n    const count = postTo.length;\n    \n    if (count === 0 || count === 3) return 'Posted To All Platforms';\n    if (count === 1) return 'Posted to ' + postTo[0].name;\n    return 'Posted to Selected Platforms';\n  })()\n}}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [
        -2976,
        304
      ],
      "id": "ab77e6c1-095e-43e1-8f37-546e2e70e2a8",
      "name": "Update Notion database",
      "credentials": {
        "notionApi": {
          "id": "je8hKPK6RzYSk4JA",
          "name": "Notion account 2"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "3b5b97b8-1def-48af-b6ad-eec7731ea64e",
              "name": "lastTweetId",
              "value": "=\t{{ $json.id }}",
              "type": "string"
            },
            {
              "id": "f99478fe-d478-49f2-95e1-2a45aa89abac",
              "name": "text",
              "value": "={{ $json.text }}",
              "type": "string"
            },
            {
              "id": "5f1cd919-4e31-425f-819c-96fa3eeaef20",
              "name": "order",
              "value": "={{ $('IF - Is This First Tweet?').item.json.order }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -2640,
        928
      ],
      "id": "f2c0b8e3-945e-440d-bdd8-0b68eeb12614",
      "name": "Prepare for Next Loop"
    },
    {
      "parameters": {
        "content": "## 2. **Asset Organization** (2 nodes)\n   - Code: Organize Assets   \n- Code: Prepare image download queue",
        "height": 112,
        "width": 400
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -5632,
        -416
      ],
      "typeVersion": 1,
      "id": "5f3d3cb3-da0e-4874-919d-b9f78264a03d",
      "name": "Sticky Note7"
    },
    {
      "parameters": {
        "content": "## 3. **Draft Extraction** (4 nodes)\n   - Download Twitter draft\n   - Download LinkedIn draft\n   - Download Blog draft\n   - Extract all three to memory",
        "height": 144,
        "width": 352,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -4704,
        -1024
      ],
      "typeVersion": 1,
      "id": "4d0ea761-8452-427b-9812-ea8928709016",
      "name": "Sticky Note8"
    },
    {
      "parameters": {
        "content": "## 4. **Image Task Processing** (2 nodes)\n   - Download image task manifest\n   - Parse image requirements",
        "height": 144,
        "width": 336,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -4352,
        -1024
      ],
      "typeVersion": 1,
      "id": "c45d808e-33c4-4294-882e-f12af7150ff4",
      "name": "Sticky Note10"
    },
    {
      "parameters": {
        "content": "## 11. **Status Tracking & Completion** (2 nodes)\n   - Update Notion with all platform links\n   - Set status to \"Posted\"\n   - Log execution metadata\n",
        "height": 304,
        "width": 512
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -3296,
        176
      ],
      "typeVersion": 1,
      "id": "887461f2-8629-4ce3-892e-589b2ff4acde",
      "name": "Sticky Note9"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4cb74fdb-0424-4441-9df0-999be5152321",
              "leftValue": "={{ $('Notion – Get Approved').first().json.property_post_to.includes('Blog') }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -5104,
        64
      ],
      "id": "05869711-1fb7-4d3d-ab9a-36f99d6ee94b",
      "name": "IF - Post to Blog?"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "14bf2db6-265a-4344-99e7-68b70300b856",
              "leftValue": "={{ $('Notion – Get Approved').first().json.property_post_to.includes('LinkedIn') }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -5088,
        448
      ],
      "id": "90683232-9536-4010-ac0f-7715aca7fb19",
      "name": "IF - Post to LinkedIn?"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "93e6e2d2-6660-4404-842d-415fca7fc1be",
              "leftValue": "={{ $('Notion – Get Approved').first().json.property_post_to.includes('X') }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -5104,
        896
      ],
      "id": "0e0d0d9e-ca82-4189-926f-be6d98cdc2b3",
      "name": "IF - Post to Twitter?"
    },
    {
      "parameters": {
        "jsCode": "// Skipped - Blog not selected\nreturn [{\n  json: {\n    platform: 'blog',\n    skipped: true,\n    success: true,\n    message: 'Blog not selected for this post'\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3984,
        80
      ],
      "id": "6e4daac0-5521-4a60-b701-d4b57361f16e",
      "name": "No-Op Blog Branch"
    },
    {
      "parameters": {
        "jsCode": "// Skipped - LinkedIn not selected\nreturn [{\n  json: {\n    platform: 'linkedin',\n    skipped: true,\n    success: true,\n    message: 'LinkedIn not selected for this post'\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4496,
        544
      ],
      "id": "a9b975dc-419f-4ff6-90d6-75e12aa9242b",
      "name": "No-Op LinkedIn Branch"
    },
    {
      "parameters": {
        "jsCode": "// Skipped - Twitter not selected\nreturn [{\n  json: {\n    platform: 'twitter',\n    skipped: true,\n    success: true,\n    message: 'Twitter not selected for this post'\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4496,
        720
      ],
      "id": "b8a74a6d-956b-4c1f-9396-27f25ed597da",
      "name": "No-Op Twitter Branch"
    },
    {
      "parameters": {
        "jsCode": "// ════════════════════════════════════════════════════════════════════════════\n// LINKEDIN PARSER (PRODUCTION v6.0 - Binary Fix)\n// ════════════════════════════════════════════════════════════════════════════\ntry {\n  const plan = $input.first().json.linkedin || {};\n  let fullFileContent = $('Set - All Data Ready').first().json.linkedinDraft;\n  if (!fullFileContent) throw new Error('LinkedIn draft content is empty.');\n  const allCachedImages = $('Loop to Download Images').all();\n  // Header Removal\n  fullFileContent = fullFileContent.replace(/^#\\s*LinkedIn\\s*Draft\\s*/i, '').trim();\n  fullFileContent = fullFileContent.replace(/^\\s*-{3,}\\s*/, '').trim();\n  // Split Posts\n  const postBlocks = fullFileContent\n    .split(/\\s*\\n-{3,}\\n\\s*/)\n    .map(block => block.trim())\n    .filter(block => block.length > 20);\n  if (postBlocks.length === 0) throw new Error('No valid post content found.');\n  const postsToExecute = postBlocks.map((block, index) => {\n    // Find image markers\n    const markersInThisBlock = Array.from(\n      block.matchAll(/<<IMAGE_(\\d+)>>/g),\n      m => parseInt(m[1])\n    );\n    let imageNumbersToAttach = [];\n    if (markersInThisBlock.length > 0) {\n      imageNumbersToAttach = markersInThisBlock;\n    } else if (index === 0 && plan.imageNumbers && plan.imageNumbers.length > 0) {\n      imageNumbersToAttach = plan.imageNumbers;\n    }\n    // Clean text\n    let cleanText = block.replace(/<<IMAGE_\\d+>>/g, '').trim();\n    // FORMATTING STRIPPER (Prevent Ghost Posts)\n    cleanText = cleanText.replace(/\\*\\*(.*?)\\*\\*/g, '$1');\n    cleanText = cleanText.replace(/\\*(.*?)\\*/g, '$1');\n    cleanText = cleanText.replace(/^#{1,6}\\s+(.*)/gm, '$1');\n    cleanText = cleanText.replace(/^\\s*[-*+]\\s+(.*)/gm, '• $1');\n    cleanText = cleanText.replace(/\\\\n/g, '\\n').replace(/\\\\\"/g, '\"');\n    cleanText = cleanText.replace(/\\n{3,}/g, '\\n\\n').trim();\n    if (cleanText.length < 10) throw new Error(`Post ${index + 1} is too short.`);\n    // Get binaries\n    let firstBinaryData = null;\n    if (imageNumbersToAttach.length > 0) {\n      const num = imageNumbersToAttach[0]; // LinkedIn usually takes 1 image\n      const targetImage = allCachedImages.find(img =>\n        img.json && img.json.fileName && img.json.fileName.includes(`asset-${num}`)\n      );\n      if (targetImage && targetImage.binary) {\n        const binaryKey = Object.keys(targetImage.binary)[0];\n        firstBinaryData = targetImage.binary[binaryKey];\n      }\n    }\n    // CRITICAL: Build output with proper n8n binary structure\n    const outputItem = {\n      json: {\n        order: index + 1,\n        text: cleanText,\n        charCount: cleanText.length,\n        hasImage: !!firstBinaryData\n      }\n    };\n    if (firstBinaryData) {\n      outputItem.binary = {\n        linkedInImage: firstBinaryData\n      };\n    }\n    return outputItem;\n  });\n  console.log(`✅ LinkedIn Parser: Generated ${postsToExecute.length} post(s)`);\n  return postsToExecute;\n} catch (error) {\n  console.error('❌ LinkedIn Parse Error:', error.message);\n  return [{ json: { error: true, message: `[LinkedIn Parse]: ${error.message}` } }];\n}"
      },
      "id": "96897f85-6f59-4125-ba4f-03a60c8c30db",
      "name": "Code - Parse & Attach LinkedIn Post",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4800,
        336
      ]
    },
    {
      "parameters": {
        "jsCode": "// ════════════════════════════════════════════════════════════════════════════\n// LINKEDIN DATA PREP (PRODUCTION v6.0)\n// Now acts as a simple passthrough since upstream handles binary correctly\n// ════════════════════════════════════════════════════════════════════════════\ntry {\n  const inputItem = $input.first();\n  const post = inputItem.json;\n  // Output structure\n  const outputItem = {\n    json: {\n      text: post.text,\n      visibility: \"PUBLIC\"\n    }\n  };\n  // Check for binary in the correct n8n location\n  if (inputItem.binary && inputItem.binary.linkedInImage) {\n    outputItem.binary = {\n      linkedInImage: inputItem.binary.linkedInImage\n    };\n  }\n  return [outputItem];\n} catch (error) {\n  return [{ json: { error: true, message: `[Prepare LinkedIn Data]: ${error.message}` } }];\n}"
      },
      "id": "8a3df9c9-8cc3-4bad-99a8-481b96efb6a8",
      "name": "Code - Prepare LinkedIn Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4336,
        352
      ]
    },
    {
      "parameters": {
        "person": "tSx0BZlecQ",
        "text": "={{ $json.text }}",
        "shareMediaCategory": "IMAGE",
        "binaryPropertyName": "linkedInImage",
        "additionalFields": {
          "visibility": "PUBLIC"
        }
      },
      "id": "d68116a0-d266-419e-999e-be1ae1b5c9af",
      "name": "LinkedIn Post",
      "type": "n8n-nodes-base.linkedIn",
      "typeVersion": 1,
      "position": [
        -4128,
        352
      ],
      "retryOnFail": false,
      "maxTries": 3,
      "waitBetweenTries": 5000,
      "credentials": {
        "linkedInOAuth2Api": {
          "id": "xiSrU49BXf76VXS1",
          "name": "LinkedIn account amansuryavanshi-ai"
        }
      }
    },
    {
      "parameters": {
        "amount": 10,
        "unit": "seconds"
      },
      "id": "5ea9bb7f-f250-4f7e-bbec-4d9ca598cdf6",
      "name": "Wait - LinkedIn Rate Limit",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [
        -3920,
        352
      ],
      "webhookId": "f4cc921f-b21d-49b0-8f7e-11724995a618"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -4576,
        336
      ],
      "id": "e82f2c77-2eb5-410c-b54d-842f4248058d",
      "name": "Loop Over Items"
    }
  ],
  "connections": {
    "Notion – Get Approved": {
      "main": [
        [
          {
            "node": "Extract Folder Details",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Start Posting": {
      "main": [
        [
          {
            "node": "Notion – Get Approved",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Folder Details": {
      "main": [
        [
          {
            "node": "List Drive Folder Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "List Drive Folder Files": {
      "main": [
        [
          {
            "node": "Organize Assets",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organize Assets": {
      "main": [
        [
          {
            "node": "Download – Image Task list",
            "type": "main",
            "index": 0
          },
          {
            "node": "Download – Twitter Draft",
            "type": "main",
            "index": 0
          },
          {
            "node": "Download – LinkedIn Draft",
            "type": "main",
            "index": 0
          },
          {
            "node": "Download – Blog Draft",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download – Image Task list": {
      "main": [
        [
          {
            "node": "Extract from File - ImageTaskList",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Image Manifest": {
      "main": [
        [
          {
            "node": "Merge - All Assets Ready",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop to Download Images": {
      "main": [
        [
          {
            "node": "Set - All Data Ready",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Download Image Binary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Image Binary": {
      "main": [
        [
          {
            "node": "Loop to Download Images",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download – Twitter Draft": {
      "main": [
        [
          {
            "node": "Extract from File - Twitter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download – LinkedIn Draft": {
      "main": [
        [
          {
            "node": "Extract from File - LinkedIn",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download – Blog Draft": {
      "main": [
        [
          {
            "node": "Extract from File - Blog",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File - ImageTaskList": {
      "main": [
        [
          {
            "node": "Parse Image Manifest",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File - Twitter": {
      "main": [
        [
          {
            "node": "Merge - All Text Ready",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File - LinkedIn": {
      "main": [
        [
          {
            "node": "Merge - All Text Ready",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Extract from File - Blog": {
      "main": [
        [
          {
            "node": "Merge - All Text Ready",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Merge - All Text Ready": {
      "main": [
        [
          {
            "node": "Merge - All Assets Ready",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge - All Assets Ready": {
      "main": [
        [
          {
            "node": "Code - Prepare Image Downloads",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code - Prepare Image Downloads": {
      "main": [
        [
          {
            "node": "Loop to Download Images",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set - All Data Ready": {
      "main": [
        [
          {
            "node": "Detect Images Needed vs Present",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Detect Images Needed vs Present": {
      "main": [
        [
          {
            "node": "IF - Post to Blog?",
            "type": "main",
            "index": 0
          },
          {
            "node": "IF - Post to LinkedIn?",
            "type": "main",
            "index": 0
          },
          {
            "node": "IF - Post to Twitter?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code - Parse Blog Content": {
      "main": [
        [
          {
            "node": "Prepare Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload Image to Sanity": {
      "main": [
        [
          {
            "node": "Loop Over Images",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "POST Blog to Sanity": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code - Parse & Attach Tweets": {
      "main": [
        [
          {
            "node": "SplitInBatches - Loop Tweets",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Tweet": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SplitInBatches - Loop Tweets": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 2
          }
        ],
        [
          {
            "node": "IF - Image Exists?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload Media to Twitter": {
      "main": [
        [
          {
            "node": "Code - Unified Tweet Preparation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Binary for Upload": {
      "main": [
        [
          {
            "node": "Upload Media to Twitter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF - Image Exists?": {
      "main": [
        [
          {
            "node": "Prepare Binary for Upload",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code - Unified Tweet Preparation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code - Unified Tweet Preparation": {
      "main": [
        [
          {
            "node": "Code - Add Parent Tweet ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code - Add Parent Tweet ID": {
      "main": [
        [
          {
            "node": "IF - Is This First Tweet?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF - Is This First Tweet?": {
      "main": [
        [
          {
            "node": "Create Tweet",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create Tweet Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Tweet Reply": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "Prepare for Next Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Image": {
      "main": [
        [
          {
            "node": "Loop Over Images",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code - Rebuild Blog Blocks with Image References": {
      "main": [
        [
          {
            "node": "POST Blog to Sanity",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Images": {
      "main": [
        [
          {
            "node": "Code - Build Image Reference Map",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Upload Image to Sanity",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code - Build Image Reference Map": {
      "main": [
        [
          {
            "node": "Code - Rebuild Blog Blocks with Image References",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Update Notion database",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare for Next Loop": {
      "main": [
        [
          {
            "node": "SplitInBatches - Loop Tweets",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF - Post to Blog?": {
      "main": [
        [
          {
            "node": "Code - Parse Blog Content",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No-Op Blog Branch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF - Post to LinkedIn?": {
      "main": [
        [
          {
            "node": "Code - Parse & Attach LinkedIn Post",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No-Op LinkedIn Branch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF - Post to Twitter?": {
      "main": [
        [
          {
            "node": "Code - Parse & Attach Tweets",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No-Op Twitter Branch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No-Op Blog Branch": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No-Op LinkedIn Branch": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "No-Op Twitter Branch": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Code - Parse & Attach LinkedIn Post": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code - Prepare LinkedIn Data": {
      "main": [
        [
          {
            "node": "LinkedIn Post",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LinkedIn Post": {
      "main": [
        [
          {
            "node": "Wait - LinkedIn Rate Limit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait - LinkedIn Rate Limit": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "Code - Prepare LinkedIn Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "instanceId": "2aff0c99a9b9ea9c976d68c5887d32445a6bdc6f59f99592eb5b4c4dbaf3d92e"
  }
}